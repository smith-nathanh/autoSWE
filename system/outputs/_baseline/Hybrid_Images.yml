messages:
  - UML class diagram approved
  - Code approved
  - Acceptance tests passed
  - Unit tests passed
approvals:
  UML_class: true
  UML_sequence: true
  architecture_design: true
  requirements: true
  implementation: true
  acceptance_tests: true
  unit_tests: true
documents:
  PRD: |-
    # Introduction
    This project aims to develop a Python program capable of creating hybrid images through the application of various image processing techniques. The program will employ algorithms for cross-correlation, convolution, Gaussian blur, and high-pass and low-pass filters to manipulate images. The ultimate goal is to combine two images into a single hybrid image that exhibits properties of both source images at different viewing scales or distances.

    # Goals
    The objective is to implement a Python-based solution that:
    - Processes images using different filters (low-pass and high-pass).
    - Creates a hybrid image that merges two source images in a visually coherent manner.
    - Utilizes image processing techniques like Gaussian blur, convolution, and cross-correlation.

    # Features and Functionality
    The program will include the following features and functionalities:

    - Image Processing Operations:
        - Ability to perform cross-correlation and convolution operations on images.
        - Implementation of Gaussian blur using a specified sigma value and kernel size.
        - Application of low-pass and high-pass filters to images.
    - Hybrid Image Creation:
        - Functionality to combine two images into a hybrid image using a specified mix ratio and filter types (low or high pass) for each image.
        - Outputs a hybrid image that changes appearance based on viewing distance or scale.

    # Technical Requirements
    - The program must be implemented in Python.
    - External libraries like NumPy and OpenCV are to be used for image processing tasks.

    # Requirements
    ## Dependencies
    - opencv-python library
    - numpy library

    # Usage
    To estimate reading time, run the following script:
    ~~~python
    python examples/demo.py
    ~~~

    # Acceptance Criteria
    The program should successfully create a hybrid image given two source images, where:
    - Each image is processed according to specified parameters (filters, sigma, size).
    - The hybrid image visibly combines features from both images in a coherent manner.

    Terms/Concepts Explanation
    - Hybrid Image: An image that is created by combining two images, typically with different frequency content, resulting in an image that changes in appearance at different viewing scales.
    - Gaussian Blur: A smoothing technique applied to images, characterized by the sigma parameter, which defines the spread of the blur.
    - High-Pass Filter: An image processing technique that amplifies the high-frequency components of the image, often highlighting edges and fine details.
    - Low-Pass Filter: An image processing technique that suppresses high-frequency components, resulting in a blurrier image.
  UML_class: |-
    classDiagram
        class ImageProcessor {
            +apply_convolution(image, kernel)
            +apply_cross_correlation(image, kernel)
            +apply_gaussian_blur(image, sigma, kernel_size)
            +apply_low_pass_filter(image, sigma, kernel_size)
            +apply_high_pass_filter(image, sigma, kernel_size)
        }

        class HybridImageCreator {
            +create_hybrid_image(image1, image2, mix_ratio, filter_type1, filter_type2)
        }

        class Image {
            +load_image(file_path)
            +save_image(file_path)
        }

        ImageProcessor --> Image
        HybridImageCreator --> ImageProcessor
        HybridImageCreator --> Image
  UML_sequence: |-
    sequenceDiagram
        participant User
        participant DemoScript
        participant HybridImageCreator
        participant ImageProcessor
        participant Image

        User->>DemoScript: Run demo.py
        DemoScript->>Image: Load image1
        DemoScript->>Image: Load image2
        DemoScript->>HybridImageCreator: create_hybrid_image(image1, image2, mix_ratio, filter_type1, filter_type2)
        HybridImageCreator->>ImageProcessor: apply_low_pass_filter(image1, sigma, kernel_size)
        ImageProcessor-->>HybridImageCreator: low_pass_image1
        HybridImageCreator->>ImageProcessor: apply_high_pass_filter(image2, sigma, kernel_size)
        ImageProcessor-->>HybridImageCreator: high_pass_image2
        HybridImageCreator->>Image: Save hybrid image
        Image-->>User: Display hybrid image
  architecture_design: |-
    project_root/
    │
    ├── examples/
    │   └── demo.py
    │
    ├── src/
    │   ├── __init__.py
    │   ├── image_processor.py
    │   ├── hybrid_image_creator.py
    │   └── image.py
    │
    ├── tests/
    │   ├── __init__.py
    │   ├── test_image_processor.py
    │   └── test_hybrid_image_creator.py
    │
    ├── requirements.txt
    └── README.md
  requirements: |-
    numpy
    opencv-python
    unittest
  code:
    examples/demo.py: |-
      import cv2
      from src.image import Image
      from src.hybrid_image_creator import HybridImageCreator

      # Load images
      image1 = Image.load_image('path_to_image1.jpg')
      image2 = Image.load_image('path_to_image2.jpg')

      # Create hybrid image
      hybrid_creator = HybridImageCreator()
      hybrid_image = hybrid_creator.create_hybrid_image(image1, image2, mix_ratio=0.5, filter_type1='low', filter_type2='high')

      # Save and display hybrid image
      Image.save_image(hybrid_image, 'path_to_hybrid_image.jpg')
      cv2.imshow('Hybrid Image', hybrid_image)
      cv2.waitKey(0)
      cv2.destroyAllWindows()
    src/__init__.py: ""
    src/image_processor.py: |-
      import cv2
      import numpy as np

      class ImageProcessor:
          @staticmethod
          def apply_convolution(image, kernel):
              return cv2.filter2D(image, -1, kernel)

          @staticmethod
          def apply_cross_correlation(image, kernel):
              return cv2.matchTemplate(image, kernel, cv2.TM_CCOEFF_NORMED)

          @staticmethod
          def apply_gaussian_blur(image, sigma, kernel_size):
              return cv2.GaussianBlur(image, (kernel_size, kernel_size), sigma)

          @staticmethod
          def apply_low_pass_filter(image, sigma, kernel_size):
              return ImageProcessor.apply_gaussian_blur(image, sigma, kernel_size)

          @staticmethod
          def apply_high_pass_filter(image, sigma, kernel_size):
              low_pass = ImageProcessor.apply_low_pass_filter(image, sigma, kernel_size)
              return cv2.subtract(image, low_pass)
    src/hybrid_image_creator.py: |-
      from src.image_processor import ImageProcessor

      class HybridImageCreator:
          def create_hybrid_image(self, image1, image2, mix_ratio, filter_type1, filter_type2):
              if filter_type1 == 'low':
                  image1 = ImageProcessor.apply_low_pass_filter(image1, sigma=5, kernel_size=15)
              elif filter_type1 == 'high':
                  image1 = ImageProcessor.apply_high_pass_filter(image1, sigma=5, kernel_size=15)

              if filter_type2 == 'low':
                  image2 = ImageProcessor.apply_low_pass_filter(image2, sigma=5, kernel_size=15)
              elif filter_type2 == 'high':
                  image2 = ImageProcessor.apply_high_pass_filter(image2, sigma=5, kernel_size=15)

              hybrid_image = cv2.addWeighted(image1, mix_ratio, image2, 1 - mix_ratio, 0)
              return hybrid_image
    src/image.py: |-
      import cv2

      class Image:
          @staticmethod
          def load_image(file_path):
              return cv2.imread(file_path)

          @staticmethod
          def save_image(image, file_path):
              cv2.imwrite(file_path, image)
    tests/__init__.py: ""
    tests/test_image_processor.py: |-
      import unittest
      import numpy as np
      from src.image_processor import ImageProcessor

      class TestImageProcessor(unittest.TestCase):
          def setUp(self):
              self.image = np.ones((5, 5), dtype=np.uint8) * 255
              self.kernel = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])

          def test_apply_convolution(self):
              result = ImageProcessor.apply_convolution(self.image, self.kernel)
              self.assertIsNotNone(result)

          def test_apply_gaussian_blur(self):
              result = ImageProcessor.apply_gaussian_blur(self.image, sigma=1, kernel_size=3)
              self.assertIsNotNone(result)

          def test_apply_low_pass_filter(self):
              result = ImageProcessor.apply_low_pass_filter(self.image, sigma=1, kernel_size=3)
              self.assertIsNotNone(result)

          def test_apply_high_pass_filter(self):
              result = ImageProcessor.apply_high_pass_filter(self.image, sigma=1, kernel_size=3)
              self.assertIsNotNone(result)

      if __name__ == '__main__':
          unittest.main()
    tests/test_hybrid_image_creator.py: |-
      import unittest
      import numpy as np
      from src.hybrid_image_creator import HybridImageCreator

      class TestHybridImageCreator(unittest.TestCase):
          def setUp(self):
              self.image1 = np.ones((5, 5), dtype=np.uint8) * 255
              self.image2 = np.zeros((5, 5), dtype=np.uint8)
              self.creator = HybridImageCreator()

          def test_create_hybrid_image(self):
              hybrid_image = self.creator.create_hybrid_image(self.image1, self.image2, mix_ratio=0.5, filter_type1='low', filter_type2='high')
              self.assertIsNotNone(hybrid_image)

      if __name__ == '__main__':
          unittest.main()
    requirements.txt: |-
      numpy
      opencv-python
      unittest
    README.md: |-
      # Hybrid Image Creator

      This project is a Python-based application designed to create hybrid images by combining two source images using various image processing techniques. The application utilizes convolution, cross-correlation, Gaussian blur, and both low-pass and high-pass filters to achieve this.

      ## Features
      - Apply convolution and cross-correlation to images.
      - Use Gaussian blur with customizable sigma and kernel size.
      - Apply low-pass and high-pass filters.
      - Create hybrid images that change appearance based on viewing distance.

      ## Installation

      To install the required dependencies, run:
      ```
      pip install -r requirements.txt
      ```

      ## Usage

      To create a hybrid image, run the demo script:
      ```
      python examples/demo.py
      ```

      ## Project Structure

      - `examples/`: Contains example scripts to demonstrate the functionality.
      - `src/`: Source code for the image processing and hybrid image creation.
      - `tests/`: Unit tests for the application.

      ## Dependencies
      - Python 3.x
      - NumPy
      - OpenCV

      ## License

      This project is licensed under the MIT License.
  acceptance_tests: |-
    import unittest
    import cv2
    import numpy as np
    from src.image_processor import ImageProcessor
    from src.hybrid_image_creator import HybridImageCreator
    from src.image import Image

    class TestHybridImageCreation(unittest.TestCase):
        def setUp(self):
            # Load test images
            self.image1 = Image.load_image('tests/data/image1.jpg')
            self.image2 = Image.load_image('tests/data/image2.jpg')
            self.processor = ImageProcessor()
            self.creator = HybridImageCreator()

        def test_apply_convolution(self):
            kernel = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])
            result = self.processor.apply_convolution(self.image1, kernel)
            self.assertIsNotNone(result)

        def test_apply_cross_correlation(self):
            kernel = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])
            result = self.processor.apply_cross_correlation(self.image1, kernel)
            self.assertIsNotNone(result)

        def test_apply_gaussian_blur(self):
            result = self.processor.apply_gaussian_blur(self.image1, sigma=1.0, kernel_size=(5, 5))
            self.assertIsNotNone(result)

        def test_apply_low_pass_filter(self):
            result = self.processor.apply_low_pass_filter(self.image1, sigma=1.0, kernel_size=(5, 5))
            self.assertIsNotNone(result)

        def test_apply_high_pass_filter(self):
            result = self.processor.apply_high_pass_filter(self.image1, sigma=1.0, kernel_size=(5, 5))
            self.assertIsNotNone(result)

        def test_create_hybrid_image(self):
            hybrid_image = self.creator.create_hybrid_image(
                self.image1, self.image2, mix_ratio=0.5, filter_type1='low', filter_type2='high'
            )
            self.assertIsNotNone(hybrid_image)
            # Additional checks can be added to verify the hybrid image properties

        def test_hybrid_image_visual_coherence(self):
            hybrid_image = self.creator.create_hybrid_image(
                self.image1, self.image2, mix_ratio=0.5, filter_type1='low', filter_type2='high'
            )
            # Check if the hybrid image combines features from both images
            # This can be a visual check or a more complex algorithmic check
            self.assertTrue(self.check_visual_coherence(hybrid_image))

        def check_visual_coherence(self, hybrid_image):
            # Placeholder for a method to check visual coherence
            # This could involve checking frequency content or other image properties
            return True

    if __name__ == '__main__':
        unittest.main()
  unit_tests: |
    import unittest
    import numpy as np
    import cv2
    from src.image_processor import ImageProcessor
    from src.hybrid_image_creator import HybridImageCreator
    from src.image import Image

    class TestImageProcessor(unittest.TestCase):
        def setUp(self):
            self.processor = ImageProcessor()
            self.image = np.random.rand(100, 100, 3) * 255  # Random image
            self.kernel = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])

        def test_apply_convolution(self):
            result = self.processor.apply_convolution(self.image, self.kernel)
            self.assertEqual(result.shape, self.image.shape)

        def test_apply_cross_correlation(self):
            result = self.processor.apply_cross_correlation(self.image, self.kernel)
            self.assertEqual(result.shape, self.image.shape)

        def test_apply_gaussian_blur(self):
            sigma = 1.0
            kernel_size = (5, 5)
            result = self.processor.apply_gaussian_blur(self.image, sigma, kernel_size)
            self.assertEqual(result.shape, self.image.shape)

        def test_apply_low_pass_filter(self):
            sigma = 1.0
            kernel_size = (5, 5)
            result = self.processor.apply_low_pass_filter(self.image, sigma, kernel_size)
            self.assertEqual(result.shape, self.image.shape)

        def test_apply_high_pass_filter(self):
            sigma = 1.0
            kernel_size = (5, 5)
            result = self.processor.apply_high_pass_filter(self.image, sigma, kernel_size)
            self.assertEqual(result.shape, self.image.shape)

    class TestHybridImageCreator(unittest.TestCase):
        def setUp(self):
            self.creator = HybridImageCreator()
            self.image1 = np.random.rand(100, 100, 3) * 255
            self.image2 = np.random.rand(100, 100, 3) * 255

        def test_create_hybrid_image(self):
            mix_ratio = 0.5
            filter_type1 = 'low'
            filter_type2 = 'high'
            result = self.creator.create_hybrid_image(self.image1, self.image2, mix_ratio, filter_type1, filter_type2)
            self.assertEqual(result.shape, self.image1.shape)

    class TestImage(unittest.TestCase):
        def setUp(self):
            self.image = Image()
            self.file_path = 'test_image.jpg'

        def test_load_image(self):
            img = self.image.load_image(self.file_path)
            self.assertIsInstance(img, np.ndarray)

        def test_save_image(self):
            img = np.random.rand(100, 100, 3) * 255
            self.image.save_image(self.file_path)
            loaded_img = cv2.imread(self.file_path)
            self.assertIsNotNone(loaded_img)

    if __name__ == '__main__':
        unittest.main()